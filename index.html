<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Th·ª£ Thi·∫øt K·∫ø VƒÉn B·∫£n Mini - L·ªõp 2</title>
    <style>
/* Reset v√† Base Styles */
* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
}

body {
    font-family: 'Segoe UI', 'Arial', sans-serif;
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    min-height: 100vh;
    display: flex;
    justify-content: center;
    align-items: center;
    padding: 20px;
}

/* Container ch√≠nh */
.game-container {
    background: white;
    border-radius: 20px;
    box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
    width: 100%;
    max-width: 1400px;
    overflow: hidden;
    animation: slideIn 0.5s ease;
}

@keyframes slideIn {
    from {
        opacity: 0;
        transform: translateY(-50px);
    }
    to {
        opacity: 1;
        transform: translateY(0);
    }
}

/* Header */
.game-header {
    background: linear-gradient(135deg, #4CAF50 0%, #45a049 100%);
    color: white;
    padding: 25px;
    text-align: center;
}

.game-header h1 {
    font-size: 32px;
    margin-bottom: 15px;
    text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.2);
    animation: pulse 2s infinite;
}

@keyframes pulse {
    0%, 100% {
        transform: scale(1);
    }
    50% {
        transform: scale(1.05);
    }
}

.game-info {
    display: flex;
    justify-content: center;
    gap: 40px;
    margin-top: 15px;
}

.score-display, .timer-display, .level-display {
    background: rgba(255, 255, 255, 0.2);
    padding: 10px 20px;
    border-radius: 25px;
    font-size: 18px;
    font-weight: bold;
    backdrop-filter: blur(10px);
}

/* Toolbar */
.toolbar {
    background: #f8f9fa;
    padding: 20px;
    border-bottom: 3px solid #e0e0e0;
    display: flex;
    gap: 20px;
    align-items: center;
    flex-wrap: wrap;
    justify-content: center;
}

.tool-group {
    display: flex;
    align-items: center;
    gap: 10px;
    padding: 10px;
    background: white;
    border-radius: 10px;
    border: 2px solid #e0e0e0;
    transition: all 0.3s;
}

.tool-group:hover {
    border-color: #4CAF50;
    transform: translateY(-2px);
    box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
}

.tool-group label {
    font-weight: bold;
    color: #333;
    font-size: 14px;
}

/* Selectors */
.font-selector, .size-selector {
    padding: 8px 15px;
    border: 2px solid #ddd;
    border-radius: 8px;
    font-size: 14px;
    background: white;
    cursor: pointer;
    transition: all 0.3s;
}

.font-selector:hover, .size-selector:hover {
    border-color: #4CAF50;
}

/* Format Buttons */
.format-btn {
    width: 45px;
    height: 45px;
    border: 2px solid #ddd;
    background: white;
    border-radius: 8px;
    font-size: 18px;
    cursor: pointer;
    transition: all 0.3s;
}

.format-btn:hover {
    background: #4CAF50;
    color: white;
    border-color: #4CAF50;
    transform: scale(1.1);
}

.format-btn.active {
    background: #2196F3;
    color: white;
    border-color: #2196F3;
}

/* Color Palette */
.color-palette {
    display: flex;
    gap: 8px;
}

.color-btn {
    width: 35px;
    height: 35px;
    border: 3px solid #fff;
    border-radius: 50%;
    cursor: pointer;
    transition: all 0.3s;
    box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
}

.color-btn:hover {
    transform: scale(1.2);
    box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3);
}

.color-btn.selected {
    border-color: #FFD700;
    transform: scale(1.2);
}

/* Help Buttons */
.help-btn {
    padding: 10px 20px;
    border: none;
    border-radius: 10px;
    font-size: 16px;
    font-weight: bold;
    cursor: pointer;
    transition: all 0.3s;
}

#hintBtn {
    background: #FFC107;
    color: #333;
}

#hintBtn:hover {
    background: #FFB300;
    transform: translateY(-2px);
    box-shadow: 0 5px 15px rgba(255, 193, 7, 0.4);
}

#resetBtn {
    background: #FF5722;
    color: white;
}

#resetBtn:hover {
    background: #F4511E;
    transform: translateY(-2px);
    box-shadow: 0 5px 15px rgba(255, 87, 34, 0.4);
}

/* Requirements Panel */
.requirements-panel {
    background: linear-gradient(135deg, #e3f2fd 0%, #bbdefb 100%);
    border: 3px solid #2196F3;
    margin: 20px 30px;
    padding: 25px;
    border-radius: 15px;
    box-shadow: 0 5px 15px rgba(33, 150, 243, 0.2);
}

.requirements-panel h3 {
    color: #1565C0;
    margin-bottom: 20px;
    font-size: 20px;
    text-align: center;
    text-transform: uppercase;
    letter-spacing: 1px;
}

.requirements-list {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
    gap: 12px;
}

.requirement-item {
    background: white;
    padding: 12px 15px;
    border-radius: 10px;
    border: 2px solid #e0e0e0;
    display: flex;
    align-items: center;
    gap: 12px;
    transition: all 0.3s ease;
    box-shadow: 0 2px 5px rgba(0, 0, 0, 0.05);
}

.requirement-item:hover {
    transform: translateY(-2px);
    box-shadow: 0 4px 10px rgba(0, 0, 0, 0.1);
}

.requirement-item.completed {
    background: #e8f5e9;
    border-color: #4CAF50;
    animation: completePulse 0.5s ease;
}

@keyframes completePulse {
    0%, 100% {
        transform: scale(1);
    }
    50% {
        transform: scale(1.05);
    }
}

.requirement-checkbox {
    width: 24px;
    height: 24px;
    border: 3px solid #ddd;
    border-radius: 6px;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 16px;
    flex-shrink: 0;
    transition: all 0.3s ease;
}

.requirement-item.completed .requirement-checkbox {
    background: #4CAF50;
    border-color: #4CAF50;
    color: white;
}

.requirement-text {
    color: #333;
    font-size: 15px;
    font-weight: 500;
    flex: 1;
}

.requirement-text .req-highlight {
    color: #D32F2F;
    font-size: 16px;
    font-weight: bold;
}

.requirement-item.completed .requirement-text {
    color: #2E7D32;
    text-decoration: line-through;
}

.requirement-item.completed .requirement-text .req-highlight {
    color: #2E7D32;
    text-decoration: line-through;
}

/* Text Area */
.text-area {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 30px;
    padding: 30px;
    background: #f5f5f5;
}

.text-panel {
    background: white;
    border-radius: 15px;
    padding: 25px;
    box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
    min-height: 400px;
}

.text-panel h3 {
    color: #333;
    margin-bottom: 20px;
    padding-bottom: 15px;
    border-bottom: 3px solid #e0e0e0;
    font-size: 20px;
}

.sample-panel {
    border: 3px solid #4CAF50;
}

.sample-panel h3 {
    color: #4CAF50;
}

.practice-panel {
    border: 3px solid #FF9800;
}

.practice-panel h3 {
    color: #FF9800;
}

.text-content {
    font-size: 16px;
    line-height: 1.8;
    padding: 15px;
    min-height: 300px;
    user-select: none;
}

.practice-panel .text-content {
    user-select: text;
    cursor: text;
}

/* Text selection */
.text-content::selection {
    background: #b3d4fc;
    color: #000;
}

/* Check Button */
.check-btn {
    display: block;
    margin: 0 auto 30px;
    padding: 15px 50px;
    background: linear-gradient(135deg, #2196F3, #1976D2);
    color: white;
    border: none;
    border-radius: 30px;
    font-size: 20px;
    font-weight: bold;
    cursor: pointer;
    transition: all 0.3s;
    box-shadow: 0 5px 15px rgba(33, 150, 243, 0.4);
}

.check-btn:hover {
    transform: translateY(-3px);
    box-shadow: 0 8px 25px rgba(33, 150, 243, 0.5);
}

.check-btn:active {
    transform: translateY(-1px);
}

/* Progress Bar */
.progress-bar {
    margin: 20px 30px 30px;
    height: 40px;
    background: #e0e0e0;
    border-radius: 20px;
    position: relative;
    overflow: hidden;
    box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.1);
}

.progress-fill {
    height: 100%;
    background: linear-gradient(90deg, #4CAF50, #8BC34A);
    border-radius: 20px;
    width: 0%;
    transition: width 0.5s ease;
    display: flex;
    align-items: center;
    justify-content: center;
}

.progress-text {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    font-weight: bold;
    color: #333;
    font-size: 16px;
}

/* Modal */
.modal {
    display: none;
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, 0.7);
    z-index: 1000;
    justify-content: center;
    align-items: center;
}

.modal.show {
    display: flex;
    animation: fadeIn 0.3s ease;
}

.modal.hidden {
    display: none;
}

@keyframes fadeIn {
    from {
        opacity: 0;
    }
    to {
        opacity: 1;
    }
}

.modal-content {
    background: white;
    padding: 40px;
    border-radius: 20px;
    text-align: center;
    max-width: 500px;
    width: 90%;
    animation: slideUp 0.5s ease;
}

@keyframes slideUp {
    from {
        transform: translateY(100px);
        opacity: 0;
    }
    to {
        transform: translateY(0);
        opacity: 1;
    }
}

.modal-content h2 {
    color: #4CAF50;
    font-size: 36px;
    margin-bottom: 20px;
}

.result-stars {
    font-size: 48px;
    margin: 20px 0;
}

.result-score, .result-time {
    font-size: 20px;
    margin: 10px 0;
    color: #333;
}

.play-again-btn {
    margin-top: 30px;
    padding: 15px 40px;
    background: linear-gradient(135deg, #4CAF50, #45a049);
    color: white;
    border: none;
    border-radius: 30px;
    font-size: 18px;
    font-weight: bold;
    cursor: pointer;
    transition: all 0.3s;
    box-shadow: 0 5px 15px rgba(76, 175, 80, 0.4);
}

.play-again-btn:hover {
    transform: translateY(-3px);
    box-shadow: 0 8px 25px rgba(76, 175, 80, 0.5);
}

/* Responsive Design */
@media (max-width: 768px) {
    .text-area {
        grid-template-columns: 1fr;
    }

    .game-info {
        flex-direction: column;
        gap: 10px;
    }

    .toolbar {
        flex-direction: column;
    }

    .game-header h1 {
        font-size: 24px;
    }
}

@keyframes slideInRight {
    from {
        transform: translateX(100%);
        opacity: 0;
    }
    to {
        transform: translateX(0);
        opacity: 1;
    }
}

.task-completed {
    opacity: 0.7;
    pointer-events: none;
}

.notification {
    transition: opacity 0.3s ease;
}
    </style>
</head>
<body>
    <!-- Container ch√≠nh -->
    <div class="game-container">

        <!-- Header v·ªõi th√¥ng tin game -->
        <header class="game-header">
            <h1>üé® Th·ª£ Thi·∫øt K·∫ø VƒÉn B·∫£n Mini</h1>
            <div class="game-info">
                <div class="score-display">
                    <span>ƒêi·ªÉm: </span>
                    <span id="score">0</span>
                </div>
                <div class="timer-display">
                    <span>‚è±Ô∏è Th·ªùi gian: </span>
                    <span id="timer">00:00</span>
                </div>
                <div class="level-display">
                    <span>C·∫•p ƒë·ªô: </span>
                    <span id="level">D·ªÖ</span>
                </div>
            </div>
        </header>

        <!-- Thanh c√¥ng c·ª• ƒë·ªãnh d·∫°ng -->
        <div class="toolbar">
            <!-- Nh√≥m ch·ªçn Font -->
            <div class="tool-group">
                <label>Font ch·ªØ:</label>
                <select id="fontFamily" class="font-selector">
                    <option value="Arial">Arial</option>
                    <option value="Times New Roman">Times New Roman</option>
                    <option value="Tahoma">Tahoma</option>
                    <option value="Comic Sans MS">Comic Sans MS</option>
                </select>
            </div>

            <!-- Nh√≥m ch·ªçn Size -->
            <div class="tool-group">
                <label>C·ª° ch·ªØ:</label>
                <select id="fontSize" class="size-selector">
                    <option value="12px">12</option>
                    <option value="14px">14</option>
                    <option value="16px">16</option>
                    <option value="18px">18</option>
                    <option value="24px">24</option>
                </select>
            </div>

            <!-- Nh√≥m n√∫t ƒë·ªãnh d·∫°ng -->
            <div class="tool-group format-buttons">
                <button id="boldBtn" class="format-btn" title="In ƒë·∫≠m">
                    <strong>B</strong>
                </button>
                <button id="italicBtn" class="format-btn" title="In nghi√™ng">
                    <em>I</em>
                </button>
                <button id="underlineBtn" class="format-btn" title="G·∫°ch ch√¢n">
                    <u>U</u>
                </button>
            </div>

            <!-- B·∫£ng m√†u -->
            <div class="tool-group color-group">
                <label>M√†u ch·ªØ:</label>
                <div class="color-palette">
                    <button class="color-btn" data-color="#000000" style="background: #000000"></button>
                    <button class="color-btn" data-color="#FF0000" style="background: #FF0000"></button>
                    <button class="color-btn" data-color="#00FF00" style="background: #00FF00"></button>
                    <button class="color-btn" data-color="#0000FF" style="background: #0000FF"></button>
                    <button class="color-btn" data-color="#FFA500" style="background: #FFA500"></button>
                    <button class="color-btn" data-color="#800080" style="background: #800080"></button>
                </div>
            </div>

            <!-- N√∫t h·ªó tr·ª£ -->
            <div class="tool-group help-buttons">
                <button id="hintBtn" class="help-btn">üí° G·ª£i √Ω</button>
                <button id="resetBtn" class="help-btn">üîÑ L√†m l·∫°i</button>
            </div>
        </div>

        <!-- B·∫£ng Y√™u C·∫ßu Nhi·ªám V·ª• -->
        <div class="requirements-panel">
            <h3>Y√™u C·∫ßu Nhi·ªám V·ª•</h3>
            <div id="requirementsList" class="requirements-list">
                <!-- Danh s√°ch y√™u c·∫ßu s·∫Ω ƒë∆∞·ª£c load b·∫±ng JS -->
            </div>
        </div>

        <!-- Khu v·ª±c vƒÉn b·∫£n ch√≠nh -->
        <div class="text-area">
            <!-- VƒÉn b·∫£n m·∫´u (b√™n tr√°i) -->
            <div class="text-panel sample-panel">
                <h3>üìù VƒÇN B·∫¢N M·∫™U</h3>
                <div id="sampleText" class="text-content">
                    <!-- N·ªôi dung m·∫´u s·∫Ω ƒë∆∞·ª£c load b·∫±ng JS -->
                </div>
            </div>

            <!-- VƒÉn b·∫£n th·ª±c h√†nh (b√™n ph·∫£i) -->
            <div class="text-panel practice-panel">
                <h3>‚úèÔ∏è VƒÇN B·∫¢N C·ª¶A EM</h3>
                <div id="practiceText" class="text-content" contenteditable="false">
                    <!-- N·ªôi dung th·ª±c h√†nh s·∫Ω ƒë∆∞·ª£c load b·∫±ng JS -->
                </div>
            </div>
        </div>

        <!-- Thanh ti·∫øn ƒë·ªô -->
        <div class="progress-bar">
            <div class="progress-fill" id="progressFill"></div>
            <span class="progress-text" id="progressText">0/5 ho√†n th√†nh</span>
        </div>

        <!-- N√∫t ki·ªÉm tra -->
        <button id="checkBtn" class="check-btn">‚úÖ Ki·ªÉm tra</button>
    </div>

    <!-- Modal k·∫øt qu·∫£ -->
    <div id="resultModal" class="modal hidden">
        <div class="modal-content">
            <h2>üéâ Ch√∫c M·ª´ng Em!</h2>
            <div class="result-stars" id="resultStars"></div>
            <p class="result-score">ƒêi·ªÉm s·ªë: <span id="finalScore">0</span></p>
            <p class="result-time">Th·ªùi gian: <span id="finalTime">00:00</span></p>
            <button id="playAgainBtn" class="play-again-btn">Ch∆°i L·∫°i</button>
        </div>
    </div>

    <script>
// Game Configuration
const gameConfig = {
    levels: {
        easy: {
            name: 'D·ªÖ',
            time: 120, // 2 ph√∫t
            tasks: [
                {
                    text: 'TR∆Ø·ªúNG C·ª¶A EM',
                    instruction: 'L√†m ch·ªØ m√†u ƒë·ªè v√† c·ª° 16px',
                    formats: {
                        color: '#FF0000',
                        fontSize: '16px'
                    },
                    requirements: [
                        { id: 'req-0-0', text: 'ƒê·ªãnh d·∫°ng ch·ªØ "TR∆Ø·ªúNG C·ª¶A EM" th√†nh: c·ª° ch·ªØ 16, m√†u ƒê·ªè', checks: [
                            { check: 'color', value: 'rgb(255, 0, 0)' },
                            { check: 'fontSize', value: '16px' }
                        ]}
                    ]
                },
                {
                    text: 'Em y√™u tr∆∞·ªùng em r·∫•t nhi·ªÅu.',
                    instruction: 'L√†m ch·ªØ "y√™u" in ƒë·∫≠m v√† "tr∆∞·ªùng em" m√†u xanh d∆∞∆°ng',
                    formats: {
                        color: '#000000',
                        fontSize: '16px',
                        fontWeight: 'normal'
                    },
                    requirements: [
                        { id: 'req-1-0', text: 'ƒê·ªãnh d·∫°ng ch·ªØ "y√™u" th√†nh: in ƒë·∫≠m', check: 'partial', target: 'y√™u', style: 'fontWeight', value: '700' },
                        { id: 'req-1-1', text: 'ƒê·ªãnh d·∫°ng ch·ªØ "tr∆∞·ªùng em" th√†nh: m√†u xanh d∆∞∆°ng', check: 'partial', target: 'tr∆∞·ªùng em', style: 'color', value: 'rgb(0, 0, 255)' }
                    ]
                },
                {
                    text: 'Gia ƒë√¨nh em c√≥ b·ªën ng∆∞·ªùi.',
                    instruction: 'L√†m ch·ªØ "Gia ƒë√¨nh" in ƒë·∫≠m v√† "b·ªën ng∆∞·ªùi" m√†u xanh',
                    formats: {
                        color: '#000000',
                        fontSize: '16px',
                        fontWeight: 'normal'
                    },
                    requirements: [
                        { id: 'req-2-0', text: 'ƒê·ªãnh d·∫°ng ch·ªØ "Gia ƒë√¨nh" th√†nh: in ƒë·∫≠m', check: 'partial', target: 'Gia ƒë√¨nh', style: 'fontWeight', value: '700' },
                        { id: 'req-2-1', text: 'ƒê·ªãnh d·∫°ng ch·ªØ "b·ªën ng∆∞·ªùi" th√†nh: m√†u xanh l√°', check: 'partial', target: 'b·ªën ng∆∞·ªùi', style: 'color', value: 'rgb(0, 255, 0)' }
                    ]
                }
            ]
        },
        medium: {
            name: 'Trung b√¨nh',
            time: 180, // 3 ph√∫t
            tasks: [
                {
                    text: 'CHUY·∫æN THAM QUAN V∆Ø·ªúN TH√ö',
                    instruction: 'C·ª° 24px, m√†u ƒë·ªè, in ƒë·∫≠m, font Arial',
                    formats: {
                        color: '#FF0000',
                        fontSize: '24px',
                        fontWeight: 'bold',
                        fontFamily: 'Arial'
                    },
                    requirements: [
                        { id: 'req-0-0', text: 'ƒê·ªïi font ch·ªØ th√†nh Arial', check: 'fontFamily', value: 'Arial' },
                        { id: 'req-0-1', text: 'ƒê·ªïi c·ª° ch·ªØ th√†nh 24px', check: 'fontSize', value: '24px' },
                        { id: 'req-0-2', text: 'L√†m ch·ªØ m√†u ƒë·ªè', check: 'color', value: 'rgb(255, 0, 0)' },
                        { id: 'req-0-3', text: 'In ƒë·∫≠m ch·ªØ', check: 'fontWeight', value: 'bold' }
                    ]
                },
                {
                    text: 'H√¥m qua, l·ªõp em ƒë√£ ƒëi tham quan v∆∞·ªùn th√∫.',
                    instruction: 'In ƒë·∫≠m "H√¥m qua", in nghi√™ng "tham quan", g·∫°ch ch√¢n "v∆∞·ªùn th√∫"',
                    formats: {
                        color: '#000000',
                        fontSize: '16px'
                    },
                    requirements: [
                        { id: 'req-1-0', text: 'In ƒë·∫≠m ch·ªØ "H√¥m qua"', check: 'partial', target: 'H√¥m qua', style: 'fontWeight', value: '700' },
                        { id: 'req-1-1', text: 'In nghi√™ng ch·ªØ "tham quan"', check: 'partial', target: 'tham quan', style: 'fontStyle', value: 'italic' },
                        { id: 'req-1-2', text: 'G·∫°ch ch√¢n ch·ªØ "v∆∞·ªùn th√∫"', check: 'partial', target: 'v∆∞·ªùn th√∫', style: 'textDecoration', value: 'underline' }
                    ]
                },
                {
                    text: 'Em ƒë√£ nh√¨n th·∫•y nhi·ªÅu con v·∫≠t d·ªÖ th∆∞∆°ng.',
                    instruction: 'M√†u xanh l√° cho "nhi·ªÅu con v·∫≠t", in ƒë·∫≠m "d·ªÖ th∆∞∆°ng"',
                    formats: {
                        color: '#000000',
                        fontSize: '16px'
                    },
                    requirements: [
                        { id: 'req-2-0', text: 'L√†m ch·ªØ "nhi·ªÅu con v·∫≠t" m√†u xanh l√°', check: 'partial', target: 'nhi·ªÅu con v·∫≠t', style: 'color', value: 'rgb(0, 255, 0)' },
                        { id: 'req-2-1', text: 'In ƒë·∫≠m ch·ªØ "d·ªÖ th∆∞∆°ng"', check: 'partial', target: 'd·ªÖ th∆∞∆°ng', style: 'fontWeight', value: '700' }
                    ]
                }
            ]
        },
        hard: {
            name: 'Kh√≥',
            time: 240, // 4 ph√∫t
            tasks: [
                {
                    text: 'B√ÄI VƒÇN C·ª¶A EM',
                    instruction: 'Font Times New Roman, c·ª° 24px, m√†u t√≠m, in ƒë·∫≠m v√† g·∫°ch ch√¢n',
                    formats: {
                        color: '#800080',
                        fontSize: '24px',
                        fontWeight: 'bold',
                        fontFamily: 'Times New Roman',
                        textDecoration: 'underline'
                    },
                    requirements: [
                        { id: 'req-0-0', text: 'ƒê·ªïi font ch·ªØ th√†nh Times New Roman', check: 'fontFamily', value: 'Times New Roman' },
                        { id: 'req-0-1', text: 'ƒê·ªïi c·ª° ch·ªØ th√†nh 24px', check: 'fontSize', value: '24px' },
                        { id: 'req-0-2', text: 'L√†m ch·ªØ m√†u t√≠m', check: 'color', value: 'rgb(128, 0, 128)' },
                        { id: 'req-0-3', text: 'In ƒë·∫≠m ch·ªØ', check: 'fontWeight', value: 'bold' },
                        { id: 'req-0-4', text: 'G·∫°ch ch√¢n to√†n b·ªô', check: 'textDecoration', value: 'underline' }
                    ]
                },
                {
                    text: 'M√πa xu√¢n ƒë√£ v·ªÅ, c√¢y c·ªëi n·ªü hoa r·∫•t ƒë·∫πp.',
                    instruction: 'In ƒë·∫≠m v√† nghi√™ng "M√πa xu√¢n", m√†u xanh l√° "c√¢y c·ªëi", m√†u ƒë·ªè "n·ªü hoa"',
                    formats: {
                        color: '#000000',
                        fontSize: '16px'
                    },
                    requirements: [
                        { id: 'req-1-0', text: 'In ƒë·∫≠m ch·ªØ "M√πa xu√¢n"', check: 'partial', target: 'M√πa xu√¢n', style: 'fontWeight', value: '700' },
                        { id: 'req-1-1', text: 'In nghi√™ng ch·ªØ "M√πa xu√¢n"', check: 'partial', target: 'M√πa xu√¢n', style: 'fontStyle', value: 'italic' },
                        { id: 'req-1-2', text: 'L√†m ch·ªØ "c√¢y c·ªëi" m√†u xanh l√°', check: 'partial', target: 'c√¢y c·ªëi', style: 'color', value: 'rgb(0, 255, 0)' },
                        { id: 'req-1-3', text: 'L√†m ch·ªØ "n·ªü hoa" m√†u ƒë·ªè', check: 'partial', target: 'n·ªü hoa', style: 'color', value: 'rgb(255, 0, 0)' }
                    ]
                }
            ]
        }
    }
};

// Game State
let gameState = {
    currentLevel: 'easy',
    score: 0,
    timeLeft: 0,
    tasksCompleted: 0,
    totalTasks: 0,
    timerInterval: null,
    currentTaskIndex: 0
};

// Initialize Game
function initGame(level = 'easy') {
    gameState.currentLevel = level;
    gameState.score = 0;
    gameState.timeLeft = gameConfig.levels[level].time;
    gameState.tasksCompleted = 0;
    gameState.currentTaskIndex = 0;
    gameState.totalTasks = gameConfig.levels[level].tasks.length;

    // Load level content
    loadLevelContent(level);

    // Setup event listeners
    setupEventListeners();

    // Start timer
    startTimer();

    // Update UI
    updateUI();
    updateCurrentTask();
}

// Load Level Content
function loadLevelContent(level) {
    const levelData = gameConfig.levels[level];
    const sampleTextDiv = document.getElementById('sampleText');
    const practiceTextDiv = document.getElementById('practiceText');
    const requirementsListDiv = document.getElementById('requirementsList');

    // Clear existing content
    sampleTextDiv.innerHTML = '';
    practiceTextDiv.innerHTML = '';
    requirementsListDiv.innerHTML = '';

    // Build requirements list for current task
    loadRequirements();

    // Build sample and practice text
    levelData.tasks.forEach((task, index) => {
        // Sample text with formatting
        const samplePara = document.createElement('p');
        samplePara.id = `sample-${index}`;
        samplePara.style.marginBottom = '15px';

        // Check if task has partial formatting requirements
        if (task.requirements && task.requirements.some(req => req.check === 'partial')) {
            // Build text with partial formatting
            let html = task.text;

            // Apply formatting for each partial requirement
            task.requirements.forEach(req => {
                if (req.check === 'partial' && req.target) {
                    let style = '';
                    switch(req.style) {
                        case 'fontWeight':
                            style = 'font-weight: 700';
                            break;
                        case 'color':
                            style = `color: ${req.value}`;
                            break;
                        case 'fontStyle':
                            style = 'font-style: italic';
                            break;
                        case 'textDecoration':
                            style = `text-decoration: ${req.value}`;
                            break;
                    }
                    // Replace target text with formatted version
                    html = html.replace(req.target, `<span style="${style}">${req.target}</span>`);
                }
            });

            // Apply base formats if any
            if (task.formats) {
                const baseStyles = [];
                if (task.formats.fontSize) baseStyles.push(`font-size: ${task.formats.fontSize}`);
                if (task.formats.fontFamily) baseStyles.push(`font-family: ${task.formats.fontFamily}`);
                samplePara.style.cssText = baseStyles.join('; ');
            }

            samplePara.innerHTML = html;
        } else {
            // Apply full paragraph formatting
            const cssText = formatsToCss(task.formats);
            samplePara.style.cssText = cssText;
            samplePara.textContent = task.text;
        }

        sampleTextDiv.appendChild(samplePara);

        // Practice text (unformatted, editable)
        const practicePara = document.createElement('p');
        practicePara.id = `practice-${index}`;
        practicePara.innerHTML = task.text; // Use innerHTML instead of textContent
        practicePara.className = 'editable-text';
        practicePara.style.marginBottom = '15px';
        practicePara.dataset.taskIndex = index;
        practiceTextDiv.appendChild(practicePara);
    });

    // Enable editing on each practice paragraph
    document.querySelectorAll('.editable-text').forEach(el => {
        el.contentEditable = 'true';
    });

    // Add event listener for real-time checking
    setupRealTimeChecking();
}

// Setup real-time checking for requirements
function setupRealTimeChecking() {
    const practiceText = document.getElementById('practiceText');
    if (!practiceText) return;

    // Check on input/change events
    let checkTimeout;
    const scheduleCheck = () => {
        clearTimeout(checkTimeout);
        checkTimeout = setTimeout(() => checkRequirements(), 300);
    };

    // Listen for various events that might change formatting
    practiceText.addEventListener('input', scheduleCheck);
    practiceText.addEventListener('DOMSubtreeModified', scheduleCheck);

    // Also check when selection changes (user might be reviewing their work)
    document.addEventListener('selectionchange', () => {
        const selection = window.getSelection();
        if (practiceText.contains(selection.anchorNode)) {
            scheduleCheck();
        }
    });
}

// Load requirements for current task
function loadRequirements() {
    const task = gameConfig.levels[gameState.currentLevel].tasks[gameState.currentTaskIndex];
    const requirementsListDiv = document.getElementById('requirementsList');

    requirementsListDiv.innerHTML = '';

    if (!task.requirements) return;

    task.requirements.forEach(req => {
        const reqItem = document.createElement('div');
        reqItem.className = 'requirement-item';
        reqItem.id = req.id;

        const checkbox = document.createElement('div');
        checkbox.className = 'requirement-checkbox';

        const text = document.createElement('div');
        text.className = 'requirement-text';

        // Format text with highlighted quoted words
        let formattedText = req.text.replace(/"([^"]+)"/g, '<span class="req-highlight">"$1"</span>');
        text.innerHTML = formattedText;

        reqItem.appendChild(checkbox);
        reqItem.appendChild(text);
        requirementsListDiv.appendChild(reqItem);
    });
}

// Convert formats object to CSS string
function formatsToCss(formats) {
    let css = [];
    if (formats.color) css.push(`color: ${formats.color} !important`);
    if (formats.fontSize) css.push(`font-size: ${formats.fontSize} !important`);
    if (formats.fontWeight) css.push(`font-weight: ${formats.fontWeight} !important`);
    if (formats.fontFamily) css.push(`font-family: ${formats.fontFamily} !important`);
    if (formats.fontStyle) css.push(`font-style: ${formats.fontStyle} !important`);
    if (formats.textDecoration) css.push(`text-decoration: ${formats.textDecoration} !important`);
    return css.join('; ');
}

// Setup Event Listeners
function setupEventListeners() {
    // Format buttons
    document.getElementById('boldBtn').addEventListener('click', (e) => {
        e.preventDefault();
        applyFormat('bold');
    });
    document.getElementById('italicBtn').addEventListener('click', (e) => {
        e.preventDefault();
        applyFormat('italic');
    });
    document.getElementById('underlineBtn').addEventListener('click', (e) => {
        e.preventDefault();
        applyFormat('underline');
    });

    // Font and size selectors
    document.getElementById('fontFamily').addEventListener('change', (e) => {
        applyFormat('fontName', e.target.value);
    });

    document.getElementById('fontSize').addEventListener('change', (e) => {
        // Use CSS font-size instead of deprecated font size attribute
        const selection = window.getSelection();
        if (selection.rangeCount && selection.toString().length > 0) {
            const range = selection.getRangeAt(0);
            const span = document.createElement('span');
            span.style.fontSize = e.target.value;

            try {
                const contents = range.extractContents();
                span.appendChild(contents);
                range.insertNode(span);

                // Reselect the text
                const newRange = document.createRange();
                newRange.selectNodeContents(span);
                selection.removeAllRanges();
                selection.addRange(newRange);

                showNotification('‚úèÔ∏è ƒê√£ √°p d·ª•ng c·ª° ch·ªØ!', 'info');
                setTimeout(() => checkRequirements(), 200);
            } catch (err) {
                console.error('Error applying font size:', err);
            }
        } else {
            showNotification('‚ö†Ô∏è Vui l√≤ng ch·ªçn vƒÉn b·∫£n tr∆∞·ªõc!', 'warning');
        }
    });

    // Color buttons - use mousedown to prevent losing selection
    document.querySelectorAll('.color-btn').forEach(btn => {
        btn.addEventListener('mousedown', (e) => {
            e.preventDefault(); // Prevent losing focus/selection

            const selection = window.getSelection();
            if (selection.rangeCount && selection.toString().length > 0) {
                const range = selection.getRangeAt(0);
                const span = document.createElement('span');
                span.style.color = e.target.dataset.color;

                try {
                    const contents = range.extractContents();
                    span.appendChild(contents);
                    range.insertNode(span);

                    // Reselect the text
                    const newRange = document.createRange();
                    newRange.selectNodeContents(span);
                    selection.removeAllRanges();
                    selection.addRange(newRange);

                    // Visual feedback
                    document.querySelectorAll('.color-btn').forEach(b => b.classList.remove('selected'));
                    e.target.classList.add('selected');

                    showNotification('‚úèÔ∏è ƒê√£ √°p d·ª•ng m√†u!', 'info');
                    setTimeout(() => checkRequirements(), 200);
                } catch (err) {
                    console.error('Error applying color:', err);
                    applyFormat('foreColor', e.target.dataset.color);
                }
            } else {
                showNotification('‚ö†Ô∏è Vui l√≤ng ch·ªçn vƒÉn b·∫£n tr∆∞·ªõc!', 'warning');
            }
        });
    });

    // Help buttons
    document.getElementById('hintBtn').addEventListener('click', showHint);
    document.getElementById('resetBtn').addEventListener('click', resetLevel);

    // Check button
    document.getElementById('checkBtn').addEventListener('click', checkCurrentTask);

    // Play again button
    document.getElementById('playAgainBtn').addEventListener('click', () => {
        document.getElementById('resultModal').classList.remove('show');
        document.getElementById('resultModal').classList.add('hidden');
        initGame(gameState.currentLevel);
    });
}

// Apply Format to Selected Text
function applyFormat(command, value = null) {
    const selection = window.getSelection();

    if (!selection.rangeCount || selection.toString().length === 0) {
        showNotification('‚ö†Ô∏è Vui l√≤ng ch·ªçn vƒÉn b·∫£n tr∆∞·ªõc!', 'warning');
        return;
    }

    // Get the range and make sure we're in practice text
    const range = selection.getRangeAt(0);
    const container = range.commonAncestorContainer;
    const practiceText = document.getElementById('practiceText');

    if (!practiceText) return;

    const practiceElement = container.nodeType === Node.TEXT_NODE
        ? container.parentElement
        : container;

    if (!practiceText.contains(practiceElement)) {
        showNotification('‚ö†Ô∏è Vui l√≤ng ch·ªçn vƒÉn b·∫£n trong khung "VƒÇN B·∫¢N C·ª¶A EM"!', 'warning');
        return;
    }

    // Apply formatting using execCommand
    practiceText.focus();

    try {
        let success = false;

        if (value) {
            success = document.execCommand(command, false, value);
        } else {
            success = document.execCommand(command, false, null);
        }

        // If execCommand failed or for certain commands, apply manually
        if (!success || command === 'foreColor') {
            const newRange = applyFormatManually(range, command, value);
            // Restore selection after manual application
            if (newRange) {
                selection.removeAllRanges();
                selection.addRange(newRange);
            }
        }
    } catch (e) {
        console.error('Error applying format:', e);
        // Fallback to manual application
        const newRange = applyFormatManually(range, command, value);
        if (newRange) {
            selection.removeAllRanges();
            selection.addRange(newRange);
        }
    }

    // Visual feedback
    showNotification('‚úèÔ∏è ƒê√£ √°p d·ª•ng ƒë·ªãnh d·∫°ng!', 'info');

    // Check requirements after applying format
    setTimeout(() => checkRequirements(), 200);
}

// Apply format manually when execCommand fails
function applyFormatManually(range, command, value) {
    const span = document.createElement('span');

    switch(command) {
        case 'bold':
            span.style.fontWeight = 'bold';
            break;
        case 'italic':
            span.style.fontStyle = 'italic';
            break;
        case 'underline':
            span.style.textDecoration = 'underline';
            break;
        case 'foreColor':
            span.style.color = value;
            break;
        case 'fontSize':
            span.style.fontSize = value;
            break;
        case 'fontName':
            span.style.fontFamily = value;
            break;
        default:
            return null;
    }

    try {
        // Extract the selected content
        const fragment = range.extractContents();

        // Add content to span
        span.appendChild(fragment);

        // Insert the span at the selection
        range.insertNode(span);

        // Create a new range that selects the content of the span
        const newRange = document.createRange();
        newRange.selectNodeContents(span);

        return newRange;
    } catch (e) {
        console.error('Error in manual format application:', e);
        return null;
    }
}

// Update current task display
function updateCurrentTask() {
    const task = gameConfig.levels[gameState.currentLevel].tasks[gameState.currentTaskIndex];
    loadRequirements();
}

// Check requirements automatically
function checkRequirements() {
    const task = gameConfig.levels[gameState.currentLevel].tasks[gameState.currentTaskIndex];
    const practiceElement = document.getElementById(`practice-${gameState.currentTaskIndex}`);

    if (!task.requirements || !practiceElement) return;

    let allRequirementsComplete = true;

    task.requirements.forEach(req => {
        let isComplete = false;

        // New format: requirement with multiple checks
        if (req.checks && Array.isArray(req.checks)) {
            isComplete = req.checks.every(checkItem =>
                checkFullRequirement(practiceElement, checkItem)
            );
        }
        // Old format: single check
        else if (req.check === 'partial') {
            // Check specific text within paragraph
            isComplete = checkPartialRequirement(practiceElement, req);
        } else {
            // Check whole paragraph style
            isComplete = checkFullRequirement(practiceElement, req);
        }

        // Update UI
        const reqElement = document.getElementById(req.id);
        if (reqElement) {
            if (isComplete) {
                reqElement.classList.add('completed');
                reqElement.querySelector('.requirement-checkbox').textContent = '‚úì';
            } else {
                reqElement.classList.remove('completed');
                reqElement.querySelector('.requirement-checkbox').textContent = '';
                allRequirementsComplete = false;
            }
        }
    });

    // Auto advance if all requirements are complete
    if (allRequirementsComplete && !practiceElement.classList.contains('task-completed')) {
        // Mark as completed
        practiceElement.classList.add('task-completed');
        practiceElement.style.border = '2px solid #4CAF50';

        gameState.tasksCompleted++;
        gameState.score += 10;

        showNotification('‚úÖ Ch√≠nh x√°c! +10 ƒëi·ªÉm', 'success');

        // Update progress
        updateProgress();

        // Move to next task or end game
        if (gameState.currentTaskIndex < gameState.totalTasks - 1) {
            setTimeout(() => {
                gameState.currentTaskIndex++;
                updateCurrentTask();
                showNotification('üìù Chuy·ªÉn sang nhi·ªám v·ª• ti·∫øp theo!', 'info');

                // Scroll to next task if needed
                const nextPractice = document.getElementById(`practice-${gameState.currentTaskIndex}`);
                if (nextPractice) {
                    nextPractice.scrollIntoView({ behavior: 'smooth', block: 'center' });
                }
            }, 1500);
        } else if (gameState.tasksCompleted === gameState.totalTasks) {
            setTimeout(() => endGame(true), 1500);
        }
    }
}

// Check requirement for full paragraph
function checkFullRequirement(element, req) {
    // Check if all text in the paragraph has the required formatting
    // We need to find the element that actually has the formatting

    let targetElement = element;

    // Try to find the deepest element that contains all the text
    function findDeepestElement(el) {
        // If element has children, check them
        if (el.children.length > 0) {
            for (let child of el.children) {
                // Check if this child contains all the text
                if (child.textContent.trim() === element.textContent.trim()) {
                    // Recursively go deeper
                    return findDeepestElement(child);
                }
            }
        }
        // No child contains all text, return this element
        return el;
    }

    targetElement = findDeepestElement(element);
    const style = window.getComputedStyle(targetElement);

    switch(req.check) {
        case 'color':
            return style.color === req.value;
        case 'fontSize':
            return style.fontSize === req.value;
        case 'fontWeight':
            const weight = style.fontWeight;
            return weight === req.value || (req.value === 'bold' && (weight === '700' || weight === 'bold'));
        case 'fontFamily':
            const family = style.fontFamily.split(',')[0].replace(/['"]/g, '').trim();
            return family.toLowerCase() === req.value.toLowerCase();
        case 'textDecoration':
            return style.textDecoration.includes(req.value);
        default:
            return false;
    }
}

// Check requirement for partial text
function checkPartialRequirement(element, req) {
    const textContent = element.textContent;
    const targetIndex = textContent.indexOf(req.target);

    console.log('Checking partial requirement for:', req.target, 'in', textContent);

    if (targetIndex === -1) {
        console.log('Target text not found');
        return false;
    }

    // Find the element containing the target text
    const walker = document.createTreeWalker(
        element,
        NodeFilter.SHOW_TEXT,
        null,
        false
    );

    let currentPos = 0;
    let targetNode = null;
    let node;

    while (node = walker.nextNode()) {
        const nodeLength = node.textContent.length;
        if (currentPos <= targetIndex && targetIndex < currentPos + nodeLength) {
            targetNode = node;
            break;
        }
        currentPos += nodeLength;
    }

    if (!targetNode) {
        console.log('Target node not found');
        return false;
    }

    // Get the parent element that has the formatting
    let parent = targetNode.parentElement;

    console.log('Parent element:', parent.tagName, parent.id || parent.className);

    // Check if we're in the practice element directly (no formatting)
    if (parent.id === `practice-${gameState.currentTaskIndex}`) {
        console.log('No formatting applied yet (still in practice element)');
        return false;
    }

    const style = window.getComputedStyle(parent);

    switch(req.style) {
        case 'color':
            console.log('Checking partial color:', style.color, 'vs', req.value);
            return style.color === req.value;
        case 'fontWeight':
            const weight = style.fontWeight;
            console.log('Checking partial fontWeight:', weight, 'vs', req.value);
            return weight === req.value || (req.value === '700' && (weight === '700' || weight === 'bold'));
        case 'fontStyle':
            console.log('Checking partial fontStyle:', style.fontStyle, 'vs', req.value);
            return style.fontStyle === req.value;
        case 'textDecoration':
            console.log('Checking partial textDecoration:', style.textDecoration, 'vs', req.value);
            return style.textDecoration.includes(req.value);
        default:
            return false;
    }
}

// Check current task formatting
function checkCurrentTask() {
    const task = gameConfig.levels[gameState.currentLevel].tasks[gameState.currentTaskIndex];
    const practiceElement = document.getElementById(`practice-${gameState.currentTaskIndex}`);

    if (!practiceElement || !task.requirements) return;

    // Check if all requirements are completed
    let allCompleted = true;
    task.requirements.forEach(req => {
        const reqElement = document.getElementById(req.id);
        if (!reqElement || !reqElement.classList.contains('completed')) {
            allCompleted = false;
        }
    });

    if (allCompleted) {
        // Mark as completed
        practiceElement.classList.add('task-completed');
        practiceElement.style.border = '2px solid #4CAF50';

        gameState.tasksCompleted++;
        gameState.score += 10;

        showNotification('‚úÖ Ch√≠nh x√°c! +10 ƒëi·ªÉm', 'success');

        // Update progress
        updateProgress();

        // Move to next task or end game
        if (gameState.currentTaskIndex < gameState.totalTasks - 1) {
            setTimeout(() => {
                gameState.currentTaskIndex++;
                updateCurrentTask();
                showNotification('üìù Chuy·ªÉn sang nhi·ªám v·ª• ti·∫øp theo!', 'info');
            }, 1500);
        } else if (gameState.tasksCompleted === gameState.totalTasks) {
            setTimeout(() => endGame(true), 1500);
        }
    } else {
        showNotification('‚ùå Ch∆∞a ho√†n th√†nh h·∫øt y√™u c·∫ßu! H√£y ki·ªÉm tra l·∫°i b·∫£ng y√™u c·∫ßu.', 'error');
    }
}

// Timer Functions
function startTimer() {
    clearInterval(gameState.timerInterval);
    gameState.timerInterval = setInterval(() => {
        gameState.timeLeft--;
        updateTimer();

        if (gameState.timeLeft <= 0) {
            endGame(false);
        }
    }, 1000);
}

function updateTimer() {
    const minutes = Math.floor(gameState.timeLeft / 60);
    const seconds = gameState.timeLeft % 60;
    const timerElement = document.getElementById('timer');
    timerElement.textContent =
        `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;

    // Warning when time is low
    if (gameState.timeLeft <= 30) {
        timerElement.style.color = '#FF0000';
        if (gameState.timeLeft === 30) {
            showNotification('‚è∞ C√≤n 30 gi√¢y!', 'warning');
        }
    } else {
        timerElement.style.color = '#FFFFFF';
    }
}

// Update Progress Bar
function updateProgress() {
    const progressPercent = (gameState.tasksCompleted / gameState.totalTasks) * 100;
    document.getElementById('progressFill').style.width = progressPercent + '%';
    document.getElementById('progressText').textContent =
        `${gameState.tasksCompleted}/${gameState.totalTasks} ho√†n th√†nh`;
}

// Show Hint
function showHint() {
    const task = gameConfig.levels[gameState.currentLevel].tasks[gameState.currentTaskIndex];
    showNotification(`üí° ${task.instruction}`, 'info');

    // Highlight current task
    const currentPractice = document.getElementById(`practice-${gameState.currentTaskIndex}`);
    if (currentPractice) {
        currentPractice.style.backgroundColor = '#FFEB3B';
        setTimeout(() => {
            currentPractice.style.backgroundColor = '';
        }, 2000);
    }
}

// Reset Level
function resetLevel() {
    if (confirm('Em c√≥ ch·∫Øc mu·ªën l√†m l·∫°i t·ª´ ƒë·∫ßu kh√¥ng?')) {
        clearInterval(gameState.timerInterval);
        initGame(gameState.currentLevel);
        showNotification('üîÑ ƒê√£ l√†m m·ªõi!', 'info');
    }
}

// End Game
function endGame(completed) {
    clearInterval(gameState.timerInterval);

    // Calculate time used
    const timeUsed = gameConfig.levels[gameState.currentLevel].time - gameState.timeLeft;

    // Calculate final score - ch·∫•m ƒëi·ªÉm d·ªÖ d√†ng cho c√°c em
    let finalScore = 0;
    let stars = '';
    let message = '';

    if (completed) {
        // Ho√†n th√†nh trong v√≤ng 1 ph√∫t: 100 ƒëi·ªÉm
        if (timeUsed <= 60) {
            finalScore = 100;
            stars = '‚≠ê‚≠ê‚≠ê';
            message = 'üéâ Xu·∫•t s·∫Øc! Em l√†m r·∫•t nhanh!';
        }
        // Ho√†n th√†nh sau 1 ph√∫t: 90 ƒëi·ªÉm
        else {
            finalScore = 90;
            stars = '‚≠ê‚≠ê‚≠ê';
            message = 'üéâ Tuy·ªát v·ªùi! Em ƒë√£ ho√†n th√†nh!';
        }
        showNotification(message, 'success');
    } else {
        // Kh√¥ng ho√†n th√†nh: kh√¥ng hi·ªán ƒëi·ªÉm
        stars = 'üí™';
        message = 'Em c·ªë g·∫Øng h∆°n l·∫ßn sau';
        finalScore = null; // Kh√¥ng hi·ªán ƒëi·ªÉm
    }

    // Show result modal
    document.getElementById('resultStars').textContent = stars;

    // Hi·ªÉn th·ªã ƒëi·ªÉm s·ªë ho·∫∑c l·ªùi ƒë·ªông vi√™n
    const scoreElement = document.getElementById('finalScore');
    const scoreContainer = scoreElement.parentElement;

    if (finalScore !== null) {
        scoreElement.textContent = finalScore;
        scoreContainer.style.display = 'block';
    } else {
        scoreContainer.style.display = 'none';
    }

    // Update message in modal
    const modalContent = document.querySelector('.modal-content h2');
    if (completed) {
        modalContent.textContent = 'üéâ Ch√∫c M·ª´ng Em!';
    } else {
        modalContent.textContent = message;
    }

    document.getElementById('finalTime').textContent = formatTime(timeUsed);

    const modal = document.getElementById('resultModal');
    modal.classList.remove('hidden');
    modal.classList.add('show');
}

// Update UI
function updateUI() {
    document.getElementById('score').textContent = gameState.score;
    document.getElementById('level').textContent = gameConfig.levels[gameState.currentLevel].name;
    updateTimer();
    updateProgress();
}

// Utility Functions
function formatTime(seconds) {
    const mins = Math.floor(seconds / 60);
    const secs = seconds % 60;
    return `${mins}:${secs.toString().padStart(2, '0')}`;
}

function showNotification(message, type = 'info') {
    // Create notification element
    const notification = document.createElement('div');
    notification.className = `notification notification-${type}`;
    notification.textContent = message;

    // Style the notification
    notification.style.cssText = `
        position: fixed;
        top: 20px;
        right: 20px;
        padding: 15px 25px;
        border-radius: 10px;
        font-weight: bold;
        z-index: 2000;
        animation: slideInRight 0.3s ease;
        box-shadow: 0 5px 15px rgba(0,0,0,0.3);
    `;

    // Set background color based on type
    switch(type) {
        case 'success':
            notification.style.background = '#4CAF50';
            notification.style.color = 'white';
            break;
        case 'warning':
            notification.style.background = '#FF9800';
            notification.style.color = 'white';
            break;
        case 'error':
            notification.style.background = '#f44336';
            notification.style.color = 'white';
            break;
        default:
            notification.style.background = '#2196F3';
            notification.style.color = 'white';
    }

    document.body.appendChild(notification);

    // Remove after 3 seconds
    setTimeout(() => {
        notification.style.opacity = '0';
        setTimeout(() => {
            notification.remove();
        }, 300);
    }, 3000);
}

// Start game when page loads
document.addEventListener('DOMContentLoaded', () => {
    initGame('easy');
    showNotification('üéÆ Ch√†o m·ª´ng ƒë·∫øn v·ªõi game! H√£y b·∫Øt ƒë·∫ßu nh√©!', 'info');
});
    </script>
</body>
</html>
